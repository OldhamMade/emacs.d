#+TITLE: Emacs Configuration
#+AUTHOR: Phillip B Oldham

* Introduction
  This file is a literate programming document written with org-mode
  and org-mode-babel which contains the configuration I use for
  development.

* To Do
** MC with Hercules
** Aggressive indent mode
https://github.com/Malabarba/aggressive-indent-mode
** DAP mode
** Aspell
https://github.com/leotaku/flycheck-aspell/
** Emacs Refactor
https://github.com/Wilfred/emacs-refactor#user-content-extension
** Better Forge interaction
*** https://github.com/sshaw/git-link
*** https://github.com/anticomputer/gh-notify
*** https://github.com/vermiculus/magithub
** CTRLF
*** Search highlighted
When test is marked/highlighted, the default search term should be
exactly that (like what deadgrep does).

* Configuration
** General improvements
*** Use lexical binding
   This buys a small improvement in performance. Every little bit
   helps!

   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; -*- lexical-binding: t; -*-
   #+END_SRC

*** Don't GC during startup to save time
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq gc-cons-percentage 0.6)
      (setq gc-cons-threshold most-positive-fixnum)
    #+END_SRC

*** Disable using tabs as indents
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq-default indent-tabs-mode nil)
    #+END_SRC

*** Enable use of the clipboard
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq select-enable-clipboard t)
    #+END_SRC

*** When I say quit, I *mean* quit
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq confirm-kill-processes nil)
    #+END_SRC
*** Allow overwriting selected text
    #+BEGIN_SRC emacs-lisp :tangle yes
    (delete-selection-mode t)
    #+END_SRC

*** Persist history over Emacs restarts.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package savehist
      :after no-littering
      :hook (emacs-startup . savehist-mode))
    #+END_SRC

*** Startup details
    It's useful to see how long the boot process took as an indicator of problems.

    #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Display load time after bootstrap
    (add-hook 'emacs-startup-hook
      (lambda ()
        (message "Emacs ready in %s with %d garbage collections."
          (format "%.2f seconds"
            (float-time
              (time-subtract after-init-time before-init-time)))
          gcs-done)))
    #+END_SRC

*** Keybinding to reload the config after editing
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun reload-init-file ()
       (interactive)
       (load-file user-init-file))

     (global-set-key (kbd "C-c C-i") 'reload-init-file)
     #+END_SRC

*** Use unicode ellipses
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq truncate-string-ellipsis "…")
    #+END_SRC

** Better GC handling
*** Define a sane value for general use
     #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar my--gc-cons-threshold 16777216)
     #+END_SRC

*** Better minibuffer GC handling
    Make sure the minibuffer operations won't trigger gc,
    so tools like =flx= won't pause.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/minibuffer-setup-hook ()
       (setq gc-cons-threshold most-positive-fixnum))

     (defun my/minibuffer-exit-hook ()
       ;; Defer it so that commands launched immediately after will enjoy the
       ;; benefits.
       (run-at-time
         1 nil (lambda () (setq gc-cons-threshold my--gc-cons-threshold))))

     (add-hook 'minibuffer-setup-hook #'my/minibuffer-setup-hook)
     (add-hook 'minibuffer-exit-hook #'my/minibuffer-exit-hook)
     #+END_SRC

*** Trigger a collection when emacs loses focus
    Take advantage of the usual development workflow by triggering
    the garbage collector when the none of the emacs frames have focus,
    usually when the user has switched to another app.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/gc-on-last-frame-out-of-focus ()
       "GC if all frames are inactive."
       (if (seq-every-p #'null (mapcar #'frame-focus-state (frame-list)))
         (garbage-collect)))

     (add-function :after after-focus-change-function
       #'my/gc-on-last-frame-out-of-focus)
     #+END_SRC

** Fundamental packages

   These packages are often required by other packages,
   and should be loaded early to avoid issues.

*** Use =general= for better key-binding

    =general.el= is intended to provide a convenient, unified interface for key
    definitions, similar to the way =use-package= provides a convenient, unified
    interface for managing packages. Its primary purpose is to build on
    existing functionality to make key definition more clear and concise.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package general)
    #+END_SRC

*** Use =add-hooks= for adding multiple hooks at once

    =add-hooks= simplifies multiple hook declarations into single declarative calls.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package add-hooks
        :ensure t
        :demand t)
    #+END_SRC

** Environment
*** macOS fixes
**** macOS modifier keys

    Re-bind the macOS modifier keys to enable =command= as =hyper=,
    providing another level of modifiers.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mac-command-modifier 'alt
          mac-option-modifier 'meta
          mac-command-modifier 'hyper
          mac-right-option-modifier nil)
    #+END_SRC

**** macOS standard keybindings

     Now that =hyper= is enabled, the standard =command + {thing}=
     keybindings for macOS need to be re-bound.

     #+BEGIN_SRC emacs-lisp :tangle yes
      (general-define-key
       ;; Select all
       "H-a" 'mark-whole-buffer
       ;; cut
       "H-x" 'kill-region
       ;; copy
       "H-c" 'kill-ring-save
       ;; paste
       "H-v" 'yank
       ;; open
       "H-o" 'find-file
       ;; save
       "H-s" 'save-buffer
       ;;  close
       "H-w" 'kill-this-buffer
       ;; quit
       "H-q" 'save-buffers-kill-emacs
       ;; minimise
       "H-m" 'iconify-frame
       ;; hide
       "H-h" 'ns-do-hide-emacs
       ;; jump to beginning of line
       "H-<left>" 'beginning-of-line
       ;; jump to end of line
       "H-<right>" 'end-of-line
       )
     #+END_SRC

     Additionally, go to the first/last point in the file when no more
     scrolling options are available, which mimics behaviour in other
     editors.

     #+BEGIN_SRC emacs-lisp :tangle yes
      (general-define-key
       ;; moving around
       "<next>" '(lambda () (interactive)
                     (condition-case nil (scroll-up)
                       (end-of-buffer (goto-char (point-max)))))
       "<prior>" '(lambda () (interactive)
                      (condition-case nil (scroll-down)
                        (beginning-of-buffer (goto-char (point-min)))))
       )
     #+END_SRC

**** Use native full-screen
     #+BEGIN_SRC emacs-lisp :tangle yes
       (setq ns-use-native-fullscreen t)
     #+END_SRC

**** Go full-screen on Startup
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'emacs-startup-hook
          (lambda ()
            (set-frame-parameter nil 'fullscreen 'fullboth)))
     #+END_SRC

**** Don't open new windows from terminal

     This stops new windows (frames) opening when
     calling emacs from the terminal with a filename

     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ns-pop-up-frames nil)
     #+END_SRC

**** Improve colour handling
     #+BEGIN_SRC emacs-lisp :tangle yes
       (setq ns-use-srgb-colorspace t)
     #+END_SRC
**** Enable better interop with OS clipboard
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq save-interprogram-paste-before-kill t)
    #+END_SRC
*** Set a flag for external tools

    It can be useful for other tools to know when they're running from
    within an Emacs buffer. For example, with the following flag set tmux
    can behave differently when running within eshell.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setenv "INSIDE_EMACS" "1")
    #+END_SRC

*** =exec-path-from-shell=

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package exec-path-from-shell
        :if (memq window-system '(mac ns))
        :demand t
        :hook (after-init . exec-path-from-shell-initialize)
        :custom
        (exec-path-from-shell-arguments '("-l")))
    #+END_SRC

*** =executable-prefix-env=

    Emacs has an =executable-prefix-env= command that adds a magic
    shebang line to scripts in interpreted languages, which can use
    =env(1)= instead of hardcoding the interpreter path, and is
    slightly more robust in certain circumstances.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq executable-prefix-env t)
    #+END_SRC

*** Integrate with ssh-agent

    Emacs instances started outside the terminal do not pick up
    ssh-agent information unless we use keychain-environment.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package keychain-environment
        :config
        (keychain-refresh-environment))
    #+END_SRC

    Note: if you keep having to enter your keychain password on macOS,
    make sure this is in =.ssh/config=:

    #+BEGIN_SRC text
    Host *
      UseKeychain yes
    #+END_SRC

*** Pick up =PATH= from =zsh= [disabled]

    Custom function to load path information from zsh.

    This has been disabled for now, to check whether
    =exec-path-from-shell= will work as expected.

    #+BEGIN_SRC emacs-lisp :tangle no
      (defun my/configure-path ()
        (let ((path (shell-command-to-string ". ~/.zshrc; echo -n $PATH")))
          (setenv "PATH" path)
          (setq exec-path
                (append
                 (split-string-and-unquote path ":")
                 exec-path))))

      (add-hook 'after-init-hook 'my/configure-path)
    #+END_SRC

*** Integrate with =direnv=

     =direnv= is a great tool for managing local environment variables
     during development. The =envrc= package integrates with Emacs
     so that programs started from within emacs, such as inferior
     shells, linters, compilers, and test runners, will be hooked up
     in the correct =$PATH=, and will be started with the correct
     environment variables set.

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package envrc
         :hook (after-init . envrc-global-mode)
         :demand t
         :general (:keymaps 'envrc-mode-map
                   "C-c E" '(envrc-command-map :which-key "envrc")))
     #+END_SRC

** Theme

    Use a theme with a dark background and good contrast.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package leiptr-theme
        :demand t
        :straight (leiptr :type git :host github :repo "OldhamMade/leiptr-theme")
        :config
          (load-theme 'leiptr t)
          )
    #+END_SRC

** Help
*** Better help

    The =helpful= package provides more readable help buffers.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helpful
      :demand t
      :commands (helpful-callable
                 helpful-key
                 helpful-variable
                 helpful-symbol)
      :config
        (defalias 'describe-key 'helpful-key)
        (defalias 'describe-function 'helpful-callable)
        (defalias 'describe-variable 'helpful-variable)
        (defalias 'describe-symbol 'helpful-symbol))
    #+END_SRC

*** Focus the =*Help*= buffer when it opens

    Forcing focus to the =*Help*= buffer when it opens means one can
    hit =q= to close it and return to editing quicker.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq help-window-select t)
    #+END_SRC

*** Integrate with =Dash.app=

    Dash.app is a wonderful resource, so it is worth integrating when
    available.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package dash-at-point
        :general (:prefix "C-c d"
                  "" '(:ignore t :which-key "Docs") ;; rename +prefix
                  "d" 'dash-at-point))
    #+END_SRC

*** Show "free" keys for new keybindings
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package free-keys)
    #+END_SRC

** Modeline
*** Show a visual bell
    The audio bell has been disabled in =early-init.el=, but it is still
    useful to have a warning when the bell would ring. This package
    flashes the modeline instead, which is less intrusive.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package mode-line-bell
        :custom (mode-line-bell-flash-time 0.4)
        :hook (emacs-startup . mode-line-bell-mode))
    #+END_SRC

*** Present a minimal modeline
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mini-modeline
      :custom
        (mini-modeline-echo-duration 3)
        (mini-modeline-right-padding 1)
        (mini-modeline-enhance-visual nil)
        (mini-modeline-r-format
          (list
            ; Modified?
            '(:eval (when (buffer-modified-p)
              (propertize "*"
                'help-echo "Buffer has been modified"
                'face 'font-lock-warning-face)))
            ; Read only?
            '(:eval (when buffer-read-only
              (propertize "!"
                'help-echo "Buffer is read-only"
                'face 'font-lock-type-face)))
            ; Current filename
            '(:eval (propertize " %b" 'help-echo (buffer-file-name)))
            ; Current git branch
            ;'(:eval (propertize '(vc-mode vc-mode)
            ;  'face 'git-commit-comment-file-face))
            '(vc-mode vc-mode)
            ;'(:eval (propertize projectile--mode-line
            ;  'help-echo "Current project"
            ;  'face 'font-lock-keyword-face))
            " "
            ; Current line and column
            (propertize "%l:%c" 'help-echo "Line and column index")
            ; Total lines
            '(:eval (propertize (format "[%s]" (or my/mode-line-buffer-line-count "?"))
              'help-echo "Total lines"
              'face 'font-lock-comment-face))
            ))
      ;:custom-face
        ;(mini-modeline-face-attr `(:background ,(face-attribute 'default :background)))
        ;(mini-modeline-mode-line ((t (:background "#FFFFFF" :box nil :height 0.1))))
        ;(mini-modeline-mode-line-inactive ((t (:background "#EEEEEE" :box nil :height 0.1))))
      :hook (after-init . mini-modeline-mode))
    #+END_SRC

*** Ensure buffer names are unique
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package uniquify
      :straight nil ;; it's a built-in
      :custom (uniquify-buffer-name-style 'forward))
    #+END_SRC

*** Display total lines in file

    It can be useful to see how many lines are in the current file,
    but we don't need this to be calculated very regularly. So this
    function will be triggered after major events to the buffer, such
    as after save.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar my/mode-line-buffer-line-count nil)
    (make-variable-buffer-local 'my/mode-line-buffer-line-count)

    (defun my/mode-line-count-lines ()
      (setq my/mode-line-buffer-line-count (int-to-string (count-lines (point-min) (point-max)))))

    (add-hooks-pair '(after-init
                      find-file
                      after-save
                      after-revert
                      dired-after-readin) 'my/mode-line-count-lines)
    #+END_SRC

** Windows
*** Quick switching between windows using =ace-window=

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ace-window
        :general
          ("M-o" 'ace-window
           "M-<tab>" 'ace-window)
        :custom
          (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
          (ace-window-display-mode t)
          (aw-dispatch-always t))
    #+END_SRC

**** Hide the cursors when ace-window is active

     #+BEGIN_SRC emacs-lisp :tangle yes
       (define-advice aw-select (:around (fun &rest r) cursor-stuff)
         (let ((cursor-in-non-selected-windows nil))
           (apply fun r)))
     #+END_SRC

**** Always trigger ace-buffer for certain actions

     #+BEGIN_SRC emacs-lisp :tangle no
       (defun my/display-buffer (buffer alist)
         (require 'ace-window)
         (let ((aw-ignore-current (cdr (assq 'inhibit-same-window alist)))
               (aw-scope (pcase (cdr (assq 'reusable-frames alist))
                           ((pred not) 'frame)
                           ('visible 'visible)
                           (_ 'global))))
           (unless (<= (length (aw-window-list)) 1)
             (window--display-buffer
              buffer (aw-select "my/display-buffer") 'reuse))))

       (setq display-buffer-base-action '((display-buffer-reuse-window
                                           my/display-buffer))
             display-buffer-alist `(,(cons "\\*helm" display-buffer-fallback-action)
                                    ("magit-diff:" (my/display-buffer)
                                     (inhibit-same-window . t))))
     #+END_SRC

*** Allow "rotating" layouts and windows

    This is configured to mimic tmux.

    #+begin_src emacs-lisp :tangle yes
    (use-package rotate
      :general ("C-c C-SPC" 'rotate-layout))
    #+end_src
*** Hide cursor in non-focussed windows
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq cursor-in-non-selected-windows nil)
    #+END_SRC
*** Persist highlight in non-focussed windows
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq highlight-nonselected-windows t)
    #+END_SRC
*** DWIM window management using =Edwina= [disabled]

    Edwina divides the frame into 2 areas, the master area and the stack. The
    master area contains the largest window(s), and other windows are placed in
    the stack.

    Edwina tries to place the master area to the side, but if the frame is too
    narrow for 2 columns it will put it on top instead.

    Disabled for now since the handling of windows can be somewhat confusing.

    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package edwina
      :hook
      (emacs-startup . edwina-mode)
      :general ("C-c w" '(:ignore t :which-key "Window")) ;; rename +prefix
      :custom
      (edwina-keymap-prefix (kbd "C-c w"))
      (display-buffer-base-action '(display-buffer-below-selected))
      :config
      (edwina-setup-dwm-keys)
      )
    #+END_SRC

*** Automatically balance windows when created

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package balanced-windows
      :hook (emacs-startup . balanced-windows-mode))
    #+END_SRC

*** Use a popup where possible

    #+begin_src emacs-lisp :tangle yes
    (use-package popwin
      :hook (emacs-startup . popwin-mode)
      :config
      (progn
        (add-to-list 'popwin:special-display-config `("*Warnings*" :height 0.5 :noselect t))
        (add-to-list 'popwin:special-display-config `("*Proccess List*" :height 0.5))
        (add-to-list 'popwin:special-display-config `("*Messages*" :height 0.5 :noselect t))
        (add-to-list 'popwin:special-display-config `("*Backtrace*" :height 0.5))
        (add-to-list 'popwin:special-display-config `("*Compile-Log*" :height 0.5 :noselect t))
        (add-to-list 'popwin:special-display-config `("*Remember*" :height 0.5))
        (add-to-list 'popwin:special-display-config `("*All*" :height 0.5))
        (add-to-list 'popwin:special-display-config `(flycheck-error-list-mode :height 0.5 :regexp t :position bottom))
        (add-to-list 'popwin:special-display-config `(occur-mode :position right :width 100))
        (add-to-list 'popwin:special-display-config `(grep-mode :position right :width 100))
        (add-to-list 'popwin:special-display-config `(special-mode :position right :width 100))
        )
        )
    #+end_src

*** Enforce rules for popup windows

    #+begin_src emacs-lisp :tangle no
      (use-package shackle
        :hook (emacs-startup . shackle-mode)
        :config
          (setq shackle-default-alignment 'right)
          (setq shackle-rules
                '(("*exunit-compilation*" :inhibit-window-quit t :align right :other t)
                  (magit-status-mode :select t :inhibit-window-quit t :align right :other t)
                  )))
    #+end_src
*** Enable Winner mode to be able to undo window changes

    #+begin_src emacs-lisp :tangle yes
      (use-package winner
        :hook (emacs-startup . winner-mode))
    #+end_src

*** Allow "zooming" a buffer to full-screen

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package zoom-window
      :init (custom-set-variables
             '(zoom-window-mode-line-color "DarkGreen"))
      :general
        ("C-x C-z" 'zoom-window-zoom))
    #+END_SRC

** Buffers
*** Initial buffer major mode: text

    Switch to =text-mode= once startup has completed.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq initial-major-mode 'fundamental-mode)
    (add-hook 'emacs-startup-hook
      (lambda ()
        (setq initial-major-mode 'text-mode)))
    #+END_SRC

*** Enforce newline at end of files
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq require-final-newline t)
    #+END_SRC

*** Enable auto-save of files as they are edited, so that no changes are lost
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package super-save
        :hook (emacs-startup . super-save-mode)
        :custom
        (super-save-auto-save-when-idle t)  ;; autosave to the real file
        (super-save-idle-duration 30)  ;; autosave idle wait
        (auto-save-default nil)  ;; disable autosave to backup file
        :config
        (add-to-list 'super-save-hook-triggers 'find-file-hook)
        )
    #+END_SRC
*** New Empty Buffer

    Mimic other editors by creating a new, numbered "untitled" buffer
    when hitting =command+n=.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/new-empty-buffer ()
        "Create a new buffer called untitled(<n>)"
        (interactive)
        (let ((newbuf (generate-new-buffer-name "untitled")))
          (switch-to-buffer newbuf)))

      (general-define-key "H-n" 'my/new-empty-buffer)
    #+END_SRC

*** Keep a list of recently accessed files

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package recentf
        :straight nil ;; it's a built-in
        :hook (emacs-startup . recentf-mode))
    #+END_SRC

*** Handle kill operations more intelligently [disabled]

    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package kill-or-bury-alive
      :general
        ("H-w" (lambda () (interactive) (kill-or-bury-alive t))
         "C-x k" 'kill-or-bury-alive
         "H-W" '(lambda () (interactive) (kill-or-bury-alive-purge-buffers t))))
    #+END_SRC

*** Add timestamps to message buffer
    Adding timestamps to messages allows us to see whether anything
    is causing emacs to block for a significant amount of time.

    #+BEGIN_SRC emacs-lisp :tangle yes
    ;;; timestamps in *Messages*
    (defun current-time-microseconds ()
      (let* ((nowtime (current-time))
             (now-ms (nth 2 nowtime)))
        (concat (format-time-string "[%Y-%m-%dT%T" nowtime) (format ".%d] " now-ms))))

    (defadvice message (before test-symbol activate)
      (if (not (string-equal (ad-get-arg 0) "%s%s"))
          (let ((deactivate-mark nil)
                (inhibit-read-only t))
            (with-current-buffer "*Messages*"
              (goto-char (point-max))
              (if (not (bolp))
                  (newline))
              (insert (current-time-microseconds))))))
    #+END_SRC
*** Make buffers without focus less prominent [disabled]

    Need to configure dimmer-prevent-dimming-predicates for
    minibuffer, corfu, vertico, etc.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package dimmer
        :hook (emacs-startup . dimmer-mode)
        :config
        (dimmer-fraction 0.1)
        (dimmer-configure-which-key)
        (dimmer-configure-magit)
        (dimmer-configure-posframe)
        )
    #+END_SRC

*** Use =ibuffer= for better buffer management

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ibuffer
        :straight nil ;; it's a built-in
        :hook (ibuffer-mode-hook . ibuffer-auto-mode)
        :general
          ("C-x C-b" 'ibuffer)
        :custom
          (ibuffer-show-empty-filter-groups nil)
        )
    #+END_SRC

*** Make sure narrowed buffers maintain their original line numbers

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq-default display-line-numbers-widen t)
    #+END_SRC

*** Make sure compilation buffers are "tailed"

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq compilation-scroll-output t)
    #+END_SRC

** Minibuffer
*** Disable ability to overwrite minibuffer prompt

    This stops the cursor entering the prompt text in the minibuffer
    when using shortcuts such as =CTRL-A=.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq minibuffer-prompt-properties
          '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
    #+END_SRC

*** Enable recursive editing

    We can make the minibuffer much more useful by enabling recursive
    usage. This means that when the minibuffer is active we can still call
    commands that require the minibuffer.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq enable-recursive-minibuffers t)
    #+END_SRC

    With this setting enabled, it's easy to lose track of whether we're
    in a recursive minibuffer or not. We display the recursion level in
    the minibuffer to avoid confusion.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (minibuffer-depth-indicate-mode 1)
    #+END_SRC

*** Minibuffer "shortcuts"

    When selecting a file to visit, // in the path will mean /
    (root) and ~ will mean $HOME regardless of preceding text

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq file-name-shadow-tty-properties '(invisible t))
    #+END_SRC

    Dim the part of the path that will be replaced.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (file-name-shadow-mode 1)
    #+END_SRC

** Cursors
*** Set cursor color based on context

    Display the cursor as grey for read-only buffers, red when in
    overwrite mode, or white otherwise. This is similar to =cursor-chg=
    but without the performance penalty.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar my/set-cursor-color-color "#FFF")
    (defvar my/set-cursor-color-buffer nil)
    (defun my/set-cursor-color-according-to-mode ()
      "change cursor color according to some minor modes."
      ;; set-cursor-color is somewhat costly, so we only call it when needed:
      (let ((color
             (if buffer-read-only
                 "#BBB"
               (if overwrite-mode
                   "#C00"
                 "#FFF"))))
        (unless (and
                 (string= color my/set-cursor-color-color)
                 (string= (buffer-name) my/set-cursor-color-buffer))
          (set-cursor-color (setq my/set-cursor-color-color color))
          (setq my/set-cursor-color-buffer (buffer-name)))))
    (add-hook 'post-command-hook 'my/set-cursor-color-according-to-mode)
    #+END_SRC

*** Remember cursor position when reopening files

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package saveplace
      :after no-littering
      :init (save-place-mode 1))
    #+END_SRC

*** Keep the cursor centered while scrolling [disabled]

    I like the idea, but I seem to struggle to work with it.

    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package centered-cursor-mode
      :hook (emacs-startup . centered-cursor-mode))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle no
      (setq scroll-preserve-screen-position t
            scroll-step 1
            scroll-margin 99999
            scroll-conservatively 10000
            ;scroll-conservatively 0
            ;scroll-up-aggressively 0.01
            ;scroll-down-aggressively 0.01
            maximum-scroll-margin 0.5
            auto-window-vscroll nil
            )
    #+END_SRC

*** Expanding regions

    Expand region increases the selected region by semantic units.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package expand-region
      :general
        (:keymaps 'global
         "M-[" #'er/expand-region
         "M-]" #'er/contract-region))
    #+END_SRC

*** Multiple cursors [disabled]

    Allows editing with multiple points on the screen.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package multiple-cursors)
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle no
       (defun mc-place ()
         "Function for the mc hercules entry point."
         (interactive))

       (use-package multiple-cursors
         :after hercules
         :bind (("s-p" . mc/mark-previous-like-this)
                ("s-n" . mc/mark-next-like-this)
            ("s-l" . mc/skip-to-previous-like-this)
            ("s-m" . mc/skip-to-next-like-this)
            ("s-d" . mc/mark-next-word-like-this)
            ("s-r" . mc/mark-all-dwim)
            (:map mc/keymap
                 ("<return>" . nil) ;; They must have bound <return>, since changing this to RET makes it not work
             ("s-s" . mc/sort-regions)))
         :config
         (defvar mc-placement-map (make-sparse-keymap))
         (let (quit)
           (bind-keys :map mc-placement-map
                  ("p" . mc/mark-previous-like-this)
                  ("n" . mc/mark-next-like-this)
                  ("P" . mc/skip-to-previous-like-this)
                  ("N" . mc/skip-to-next-like-this)
                  ("d" . mc/mark-next-word-like-this)
                  ("D" . mc/mark-previous-word-like-this)
                  ("r" . mc/mark-all-dwim)
                  ("=" . er/expand-region)
                  ("RET" . quit)
                  ("q" . quit))
           (hercules-def
            :toggle-funs #'mc-place
            :hide-funs 'quit
            :keymap 'mc-placement-map
            :transient t)
           )
       :general ("C-c m" 'mc-place))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package multiple-cursors
       :init
         (defun my/mc-place (interactive) (message "Entering mc-mode"))
         (defvar my/mc-map (make-sparse-keymap))
       :general
         (:prefix "C-c m"
          :prefix-map 'my/mc-map
           "" '(:ignore t :which-key "Multiple Cursors") ;; rename +prefix
           "n" #'mc/mark-next-like-this
           "p" #'mc/mark-previous-like-this
           "j" #'mc/skip-to-next-like-this
           "-" #'mc/skip-to-previous-like-this
           "a" #'mc/mark-all-like-this
           "N" #'mc/mark-next-symbol-like-this
           "P" #'mc/mark-previous-symbol-like-this
           "A" #'mc/mark-all-symbols-like-this
           "." #'mc/mark-all-dwim
           "1" #'mc/insert-numbers
           "L" #'mc/insert-letters
           "l" #'mc/edit-lines
           "s" #'mc/sort-regions
           "r" #'mc/reverse-regions
           "<return>" nil
           )
       :config
         (hercules-def
           ;:keymap 'my/mc-map
           :keymap 'mc/keymap
           :transient t)
         )
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package multiple-cursors
       :commands
          (mc/mark-next-like-this
           mc/mark-previous-like-this
           mc/skip-to-next-like-this
           mc/skip-to-previous-like-this
           mc/mark-all-like-this
           mc/mark-next-symbol-like-this
           mc/mark-previous-symbol-like-this
           mc/mark-all-symbols-like-this
           mc/mark-all-dwim
           mc/insert-numbers
           mc/insert-letters
           mc/edit-lines
           mc/sort-regions
           mc/reverse-regions
           )
       :general
         (:prefix-map 'my/mc-map
           "" '(:ignore t :which-key "Multiple Cursors") ;; rename +prefix
           "n" #'mc/mark-next-like-this
           "p" #'mc/mark-previous-like-this
           "j" #'mc/skip-to-next-like-this
           "-" #'mc/skip-to-previous-like-this
           "a" #'mc/mark-all-like-this
           "N" #'mc/mark-next-symbol-like-this
           "P" #'mc/mark-previous-symbol-like-this
           "A" #'mc/mark-all-symbols-like-this
           "." #'mc/mark-all-dwim
           "1" #'mc/insert-numbers
           "L" #'mc/insert-letters
           "l" #'mc/edit-lines
           "s" #'mc/sort-regions
           "r" #'mc/reverse-regions
           "<return>" nil
           )
         (:prefix "C-c m"
           "" '(:ignore t :which-key "Multiple Cursors") ;; rename +prefix
           )
       :config
         (hercules-def
           :toggle-funs #'multiple-cursors
           :keymap 'my/mc-map
           :transient t)
         )
     #+END_SRC

*** Smart regions

    Smart region guesses what you want to select by one command:

    - If you call this command multiple times at the same position, it
      expands the selected region (with `er/expand-region').
    - Else, if you move from the mark and call this command, it selects
      the region rectangular (with `rectangle-mark-mode').
    - Else, if you move from the mark and call this command at the same
      column as mark, it adds a cursor to each line (with `mc/edit-lines').

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package smart-region
        :hook (window-setup . smart-region-on))
    #+END_SRC
*** Deploy multiple cursors to edit all occurrences of symbol at point

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package iedit)
    #+END_SRC

*** Use =avy= to move the cursor around quickly

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package avy
        :general
        ("C-'" 'avy-goto-char-timer
         "C-=" 'avy-goto-char-timer))
    #+END_SRC

*** Pulse the active line after movement commands

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package pulsar
        :hook ((emacs-startup . pulsar-global-mode)
               (consult-after-jump-hook . pulsar-recenter-middle)
               (consult-after-jump-hook . pulsar-reveal-entry))
        :custom
          (pulsar-pulse t)
          (pulsar-delay 0.055)
          (pulsar-pulse-functions '(recenter-top-bottom
                                    move-to-window-line-top-bottom
                                    reposition-window
                                    bookmark-jump
                                    other-window
                                    delete-window
                                    delete-other-windows
                                    forward-page
                                    backward-page
                                    scroll-up-command
                                    scroll-down-command
                                    windmove-right
                                    windmove-left
                                    windmove-up
                                    windmove-down
                                    windmove-swap-states-right
                                    windmove-swap-states-left
                                    windmove-swap-states-up
                                    windmove-swap-states-down
                                    tab-new
                                    tab-close
                                    tab-next
                                    org-next-visible-heading
                                    org-previous-visible-heading
                                    org-forward-heading-same-level
                                    org-backward-heading-same-level
                                    outline-backward-same-level
                                    outline-forward-same-level
                                    outline-next-visible-heading
                                    outline-previous-visible-heading
                                    outline-up-heading
                                    ctrlf-forward-default
                                    ctrlf-backward-default
                                    ctrlf-forward-alternate
                                    ctrlf-backward-alternate
                                    ctrlf-forward-symbol
                                    ctrlf-forward-symbol-at-point
                                    consult-line)))
    #+END_SRC

** Browsing
*** Do what I mean!

    Context-sensitive external browse URL or Internet search from Emacs.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package browse-url-dwim
        :hook (emacs-startup . browse-url-dwim-mode))
    #+END_SRC

** Completion
*** Fast and minimal vertical completion UI with =Vertico=

    Vertico provides a performant and minimalistic vertical completion UI
    based on the default completion system.

    In this case, =vertico-reverse-mode= is enabled to ensure that the
    text-entry part of the minibuffer does not jump around.

    =vertico-indexed-mode= has also been enabled, so that using =C-{index} RET=
    will trigger the option at that =index=.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package vertico
        :straight (vertico :files (:defaults "extensions/*")
                           :includes (vertico-indexed
                                      vertico-reverse
                                      vertico-multiform))
        :hook ((emacs-startup . vertico-mode)
               ;(emacs-startup . vertico-indexed-mode)
               ;(emacs-startup . vertico-reverse-mode)
               )
        :custom
          (vertico-resize t)
          (vertico-cycle t)
          (read-file-name-completion-ignore-case t)
          (read-buffer-completion-ignore-case t)
          (completion-ignore-case t)
        )
    #+END_SRC
        :general
          (:keymaps 'minibuffer-local-map
           "<backspace>" 'my/minibuffer-backward-kill)

**** Mimic the way =ivy= jumps back a folder when hitting backspace [DISABLED]

     Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608

     Disabled for now as I don't like the behaviour. What I want is
     for this to jump up a directory if deleting at a =/= char,
     otherwise delete a char. Eg:

     =/opt/thing/foo|= < backspace here would delete =o=
     =/opt/thing/|= < backspace here would delete =thing/=

     #+BEGIN_SRC emacs-lisp :tangle no
     (defun my/minibuffer-backward-kill (arg)
       "When minibuffer is completing a file name delete up to parent
     folder, otherwise delete a character backward"
       (interactive "p")
       (if minibuffer-completing-file-name
           (if (string-match-p "/." (minibuffer-contents))
               (zap-up-to-char (- arg) ?/)
             (delete-minibuffer-contents))
           (delete-backward-char arg)))
     #+END_SRC

*** Enable richer completion annotations with =Marginalia=

     Marginalia are marks or annotations placed at the margin of the page of
     a book, or in this case helpful colorful annotations placed at the margin
     of the minibuffer for completion candidates.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package marginalia
       :after vertico
       :hook (emacs-startup . marginalia-mode)
       )
     #+END_SRC

*** Enable fuzzy matching of completions using =Orderless=

     The =orderless= package provides an "orderless" completion style that
     divides the pattern into space-separated components, and matches candidates
     that match all of the components in any order. Each component can match in
     any one of several ways: literally, as a regexp, as an initialism, in the
     flex style, or as multiple word prefixes.

     Here the matching styles have been set so that (for example) typing:

     =qrr= will provide a first match of =query-replace-regex=

     =sl= or =sort= will provide a first match of =sort-lines=

     Everything else is "fuzzy", so =ispl= will match in the middle of words
     such as =display=.

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package orderless
         :custom
         (completion-styles '(orderless basic))
         (completion-category-defaults nil)
         (completion-category-overrides '((file (styles substring partial-completion))))
         (orderless-matching-styles
          '(orderless-initialism
            orderless-prefixes
            orderless-literal
            orderless-flex
            orderless-regexp
            ))
         )
     #+END_SRC

*** Practical command completions care of =Consult=

    Consult provides practical commands based on the Emacs completion
    function =completing-read=. Completion allows quick selection of an
    item from a list of candidates. Consult tries to offer an improved
    list of suggestions.

      (defun my/get-project-root ()
        (when (fboundp 'project-current)
          (project-current)))

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package consult
        ;:requires (vertico orderless)
        :hook (completion-list-mode . consult-preview-at-point-mode)
        :general
          ("C-x b" 'consult-buffer
           "C-x M-:" 'consult-complex-command
           "C-x r b" 'consult-bookmark
           "C-x p b" 'consult-project-buffer)
          (:keymaps 'minibuffer-local-map
           "C-r" 'consult-history)
          (:keymaps 'goto-map
           "g" 'consult-goto-line
           "M-g" 'consult-goto-line ;; useful shortcut
           )
          (:prefix "C-c r"
           "" '(:ignore t :which-key "Registers") ;; rename +prefix
           "l" 'consult-register-load
           "s" 'consult-register-save
           "r" 'consult-register
           )
        :custom
        (register-preview-delay 0.3)
        ;(consult-project-root-function #'my/get-project-root)
        ;(consult-project-root-function #'projectile-project-root)

        ;; Configure a different project root function.
        (autoload 'projectile-project-root "projectile")
        (setq consult-project-function (lambda (_) (projectile-project-root)))

        (completion-in-region-function #'consult-completion-in-region)

        ;; Use Consult to select xref locations with preview
        (xref-show-xrefs-function #'consult-xref)
        (xref-show-definitions-function #'consult-xref)

        ;; This adds thin lines, sorting and hides the mode line of the window.
        (advice-add #'register-preview :override #'consult-register-window)

        ;; Replace `completing-read-multiple' with an enhanced version.
        (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
        )
    #+END_SRC

**** Better directory navigation with =consult-dir=

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package consult-dir
         :ensure t
         :general
           ("C-x C-d" 'consult-dir)
           (:keymaps 'vertico-map
             "C-x C-d" 'consult-dir
             "C-x C-j" 'consult-dir-jump-file)
         :custom
         (consult-dir-project-list-function #'consult-dir-projectile-dirs)
         )
     #+END_SRC

**** =lsp-mode= integration

     https://github.com/gagbo/consult-lsp

     Seems to break xref-find-definition, so disabled for now.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package consult-lsp
         :config
         (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols))
     #+END_SRC

*** Contextual commands care of =Embark=

    Embark provides a sort of right-click contextual menu for Emacs, accessed
    through the =embark-act= command (here bound to =C-.=), offering relevant
    actions to use on a target determined by the context

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package embark
        :general
        ("C-." 'embark-act
         "M-." 'embark-dwim
         "C-h B" 'embark-bindings)
        :custom
        (prefix-help-command #'embark-prefix-help-command)
        (embark-mixed-indicator-delay 0.1) ;; show embark popup quicker
        :config
        ;; Don't quit the minibuffer after removing a buffer from the list
        (setq embark-quit-after-action '((kill-buffer . t) (t . nil)))
        (setq embark-verbose-indicator-display-action
          '(display-buffer-at-bottom
            (window-height . (lambda (win) (fit-window-to-buffer
                                       win (floor (frame-height)
                                                  3))))))
        )
    #+END_SRC

**** Integrate with =consult=

     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package embark-consult
       :after (consult embark)
       :hook (embark-collect-mode . consult-preview-at-point-mode))
     #+END_SRC

*** Enhance completion-at-point with =Corfu=

    Corfu enhances completion at point with a small completion
    popup. The current candidates are shown in a popup below or above
    the point. Corfu is the minimalistic =completion-in-region=
    counterpart of the =Vertico= minibuffer UI.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package corfu
        :hook (lsp-completion-mode . my/corfu-setup-lsp)
        :general
        ;("<tab>" 'completion-at-point)
        (:keymaps 'corfu-map
         "<tab>" 'corfu-insert
         "<escape>" 'corfu-quit
         "<return>" 'corfu-insert
         "M-d" 'corfu-show-documentation)
        :init
        (setq tab-always-indent 'complete)
        :custom
        (completion-cycle-threshold nil)
        (corfu-auto t) ;; Enable auto completion
        (corfu-cycle t) ;; Enable cycling for `corfu-next/previous'
        (corfu-auto-prefix 2) ;; Minimum length of prefix for auto completion.
        (corfu-auto-delay 0.2)
        ;; (corfu-separator ?\s)          ;; Orderless field separator
        ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
        ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
        ;; (corfu-preview-current nil)    ;; Disable current candidate preview
        ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
        ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
        ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
        ;; (corfu-scroll-margin 5)        ;; Use scroll margin
        (corfu-quit-at-boundary 'separator)     ; a non-nil value is necessary
        (corfu-separator ?\s)                   ; Use space
        (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
        (corfu-preview-current 'insert)  ; Preview current candidate?
        (lsp-completion-provider :none)
        :config
        (defun my/corfu-setup-lsp ()
          "Use orderless completion style with lsp-capf instead of the
           default lsp-passthrough."
          (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
                '(orderless)))
        :init
        (global-corfu-mode)
        )
    #+END_SRC


    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package corfu
        :init
        (setq tab-always-indent 'complete)
        (setq lsp-completion-provider :none)
        (defun my/corfu-setup-lsp ()
          "Use orderless completion style with lsp-capf instead of the
           default lsp-passthrough."
          (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
                '(orderless)))
        :hook (lsp-completion-mode . my/corfu-setup-lsp)
        :general
        ;("<tab>" 'completion-at-point)
        (:keymaps 'corfu-map
         "<tab>" 'corfu-insert
         "<escape>" 'corfu-quit
         "<return>" 'corfu-insert
         "M-d" 'corfu-show-documentation)
        :custom
        (completion-cycle-threshold nil)
        (corfu-auto t) ;; Enable auto completion
        (corfu-cycle t) ;; Enable cycling for `corfu-next/previous'
        (corfu-auto-prefix 2) ;; Minimum length of prefix for auto completion.
        (corfu-auto-delay 0.2)
        ;; (corfu-separator ?\s)          ;; Orderless field separator
        ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
        ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
        ;; (corfu-preview-current nil)    ;; Disable current candidate preview
        ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
        ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
        ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
        ;; (corfu-scroll-margin 5)        ;; Use scroll margin
        (corfu-quit-at-boundary 'separator)     ; a non-nil value is necessary
        (corfu-separator ?\s)                   ; Use space
        (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
        (corfu-preview-current 'insert)  ; Preview current candidate?
        :init
        (global-corfu-mode)
        )
    #+END_SRC

**** Use dabbrev with Corfu

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package dabbrev
         ;; Swap M-/ and C-M-/
         :general ("M-/" 'dabbrev-completion
                   "C-M-/" 'dabbrev-expand)
         :custom
         (dabbrev-case-fold-search nil)
         (dabbrev-case-replace nil))
     #+END_SRC

*** Enhance completion-at-point again with =Cape=

    Cape provides a bunch of Completion At Point Extensions which can
    be used in combination with Corfu completion UI or the default
    completion UI.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package cape
        :init
        ;; Add `completion-at-point-functions', used by `completion-at-point'.
        (add-to-list 'completion-at-point-functions #'cape-dabbrev)
        (add-to-list 'completion-at-point-functions #'cape-keyword)
        (add-to-list 'completion-at-point-functions #'cape-file)
        (add-to-list 'completion-at-point-functions #'cape-sgml)
        ;;(add-to-list 'completion-at-point-functions #'cape-ispell)
        ;;(add-to-list 'completion-at-point-functions #'cape-dict)
        ;;(add-to-list 'completion-at-point-functions #'cape-tex)
        ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
        ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
        ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
        ;;(add-to-list 'completion-at-point-functions #'cape-line)
        :custom
        (completion-at-point-functions
         (list (cape-super-capf #'cape-dabbrev #'cape-keyword #'cape-file #'cape-sgml)))
        )
    #+END_SRC

*** Command discovery care of =which-key=

    =which-key= is a minor mode for Emacs that displays the key bindings
    following your currently entered incomplete command (a prefix) in
    a popup. For example, after enabling the minor mode if you enter
    =C-x= and wait for the default of 1 second the minibuffer will
    expand with all of the available key bindings that follow =C-x= (or
    as many as space allows given your settings).

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package which-key
        :hook (emacs-startup . which-key-mode)
        :custom
        (which-key-enable-extended-define-key t)
        (which-key-idle-delay .4)
        (which-key-side-window-location 'bottom)
        (which-key-side-window-max-height 0.25))
    #+END_SRC

*** Sequential key commands via =hercules=

    =hercules.el= lets one call any group of related command
    sequentially with no prefix keys, while showing a handy
    =which-key=-style popup to remember the bindings for those
    commands.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package hercules)
    #+END_SRC

*** Make the =goto-map= keymap better

    =M-g=, the =goto-map=, is somewhat limited. Since we have =avy=
    and it's friends, let's add further options.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (general-define-key
      :keymaps 'goto-map
      "<up>" 'beginning-of-buffer
      "<down>" 'end-of-buffer
      "<left>" '("previous mark" . pop-global-mark)
      )
    #+END_SRC

*** Jump back to the last edit

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package goto-last-change
        :general
          (:keymaps 'goto-map
           "-" 'goto-last-change))
    #+END_SRC

*** Move Where I Mean with =mwim= (similar to =dwim=)

    =C-a= and =C-e= normally moves the cursor to the beginning/end of
    the line unconditionally.

    =mwim= is more useful, as it moves to the first non-whitespace
    character if we're already at the beginning of the line. Repeated
    use of =C-a= toggles between these two positions.

    =C-e= will toggle to the end of the line ignoring comments, or to
    the true end of the line.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mwim
      :commands (mwim-beginning mwim-end)
      :general
        (:keymaps 'override
          "C-a" #'mwim-beginning
          "C-e" #'mwim-end
          "H-<left>" #'mwim-beginning
          "H-<right>" #'mwim-end))
    #+END_SRC

** History
*** Undo/redo
**** Add =undo-fu= for better undo behaviour
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package undo-fu
       :general
         ("H-z" #'undo-fu-only-undo)
         ("H-Z" #'undo-fu-only-redo))
     #+END_SRC

**** Add =undo-fu-session= for history
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package undo-fu-session
         :requires undo-fu
         :custom
           (undo-fu-session-directory (expand-file-name "~/Dropbox/.emacs.persist/.undohist"))
           (undo-fu-session-incompatible-files
             '("COMMIT_EDITMSG"
               "NOTES_EDITMSG"
               "MERGE_MSG"
               "TAG_EDITMSG"
               "\\.gpg\\'"
               "/tmp"
               file-remote-p)))
     #+END_SRC

**** Highlight undo/redo sections
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package undo-hl
         :straight (undo-hl :type git :host github :repo "casouri/undo-hl")
         :hook (after-init . undo-hl-mode))
     #+END_SRC
*** Add "dog ears" to return to previous edit points [DISABLED]
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package dogears
        :straight (dogears :type git :host github :repo "alphapapa/dogears.el")
        :config
          (add-to-list 'dogears-hooks 'consult-after-jump-hook)
        :general
        (:keymaps 'goto-map
         "h" '(:ignore t :which-key "history") ;; rename +prefix
         "h h" 'dogears-go
         "h b" 'dogears-back
         "h f" 'dogears-forward
         "h l" 'dogears-list
         "h s" 'dogears-sidebar))
    #+END_SRC
** Editing
*** Enable subword mode
    #+BEGIN_SRC emacs-lisp :tangle yes
      (global-subword-mode 1)
    #+END_SRC

*** Always append a new line to the file
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq require-final-newline t)
    #+END_SRC

*** Always delete trailing whitespace on save
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-hook 'before-save-hook #'delete-trailing-whitespace)
    #+END_SRC

*** Clean whitespace intelligently on key-press
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package shrink-whitespace
        :general
          ("<S-backspace>" #'shrink-whitespace))
    #+END_SRC

*** Add useful keyboard shortcuts with =crux=
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package crux
      :hook (find-file-hook . crux-reopen-as-root)
      :general
        ("C-k" 'crux-smart-kill-line
         "M-D" #'crux-duplicate-current-line-or-region
         "H-<backspace>" 'crux-cleanup-buffer-or-region)
        (:keymaps 'override
         :prefix "C-c C-f"
         "" '(:ignore t :which-key "File & Buffer") ;; rename +prefix
         "r" 'crux-rename-file-and-buffer
         "k" 'crux-delete-file-and-buffer)
        (:keymaps 'override
         :prefix "C-c c"
         "" '(:ignore t :which-key "Change case") ;; rename +prefix
         "c" 'crux-capitalize-region
         "u" 'crux-upcase-region
         "l" 'crux-downcase-region
         )
       :config
         (crux-reopen-as-root-mode)
      )
    #+END_SRC

*** Toggle between inflections

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package string-inflection-custom
        :straight (string-inflection :type git :host github :repo "OldhamMade/string-inflection")
        :general
          ("C--" 'string-inflection-all-cycle)
        :hook (elixir-mode . (lambda ()
                               (local-set-key (kbd "C--") 'string-inflection-elixir-style-cycle)))
        )
    #+END_SRC

*** Keybinding to toggle between fill/unfill
    Unfill adds the inverse of fill-paragraph/-region.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package unfill
      :general ("M-q" 'unfill-toggle))
    #+END_SRC

*** Parens/pairs
**** Auto-pair braces

     =electric-pair-mode= will insert a trailing paren/brace/etc when a
     leading one is entered, to keep things balanced.

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package electric-pair-mode
         :straight nil ;; it's a built-in
         :hook (emacs-startup . electric-pair-mode)
         :custom
         (electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
         :init
         (add-hook 'minibuffer-setup-hook (lambda () (electric-pair-mode 0)))
         (add-hook 'minibuffer-exit-hook (lambda () (electric-pair-mode 1)))
         )
     #+END_SRC

*** Indents
**** Enable automatic indenting
     #+BEGIN_SRC emacs-lisp :tangle yes
     (electric-indent-mode +1)
     #+END_SRC
**** Set tab width to 4 for all buffers
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default tab-width 4)
     #+END_SRC

*** Whitespace

    #+begin_src emacs-lisp :tangle yes
    (use-package whitespace
      :hook ((prog-mode web-mode) . whitespace-mode)
      :custom
        ; Show bad whitespace
        (whitespace-style '(face lines-tail
                                 trailing space-before-tab
                                 indentation empty space-after-tab))
        ; Highlight long lines for prog/web modes
        (whitespace-line-column 80)
      :config
        (setq show-trailing-whitespace t)
      )
    #+end_src

**** Make sure sneaky no-break spaces are displayed.
     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq nobreak-char-display 0)
     #+END_SRC

*** Move text with =M-<up>= and =M-<down>=
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package move-text
      :hook (emacs-startup . move-text-default-bindings))
    #+END_SRC

*** Highlighting

**** Highlight the current line
     Highlighting the entire line can mess with packages that set their own
     background colors, because hl-line uses an overlay which overlays all
     backgrounds below it.

     Instead, this function only highlights the "end" of the line, which is
     good enough as a visual indicator to find the cursor and has the benefit
     of being less intrusive.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/hl-line-range-function ()
         (cons (line-end-position) (line-beginning-position 2)))

     (setq hl-line-range-function #'my/hl-line-range-function)
     (global-hl-line-mode 1)
     #+END_SRC

**** Syntax highlighting by default
     #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'emacs-startup-hook
       (lambda () (global-font-lock-mode 1)))
     #+END_SRC

**** Indentation
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package highlight-indentation
       :hook ((prog-mode sass-mode yaml-mode) . highlight-indentation-mode)
       :config
         (set-face-background 'highlight-indentation-face "#222"))
     #+END_SRC

**** Colour references, displaying the colour referenced
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package rainbow-mode
       :hook (sass-mode css-mode emacs-lisp-mode))
    #+END_SRC

*** Symbols

    #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'emacs-startup-hook
      (lambda () (global-prettify-symbols-mode +1)))
    #+END_SRC

*** Delimiters
**** Show paren pairs
     I want to see the paren matches, but I don't want to be too
     distracted by them.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (setq show-paren-delay 0.01
           show-paren-style 'parenthesis)
     (set-face-background 'show-paren-match "#456")
     (set-face-foreground 'show-paren-match "#cde")
     (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
     (show-paren-mode t)
     #+END_SRC

** Copy/Paste
*** Allow copying a region in a format ready for external services
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package copy-as-format
        :general
        (:prefix "C-c H-c"
         "" '(:ignore t :which-key "Copy-as-format") ;; rename +prefix
         "s" 'copy-as-format-slack
         "g" 'copy-as-format-github
         "l" 'copy-as-format-gitlab
         "b" 'copy-as-format-bitbucket
         "j" 'copy-as-format-jira
         "m" 'copy-as-format-markdown
         "r" 'copy-as-format-rst
         "h" 'copy-as-format-html
         ))
    #+END_SRC
*** Persist mark after =kill-ring-save=

    Taken from https://emacs.stackexchange.com/questions/37980/how-to-save-the-text-selection-and-keep-the-selection-highlight

    #+BEGIN_SRC emacs-lisp :tangle yes
      (define-advice kill-ring-save (:around (old-fun &rest args) highlight)
        "Save the text selection and keep the selection highlight."
        (let (deactivate-mark)
          (apply old-fun args)
          (message "Copied!")))
    #+END_SRC

** Search/replace
*** Make in-buffer search more intuitive with =CTRLF=

    =CTRLF= (pronounced "control F") is an intuitive and efficient
    solution for single-buffer text search in Emacs, replacing
    packages such as Isearch, Swiper, and helm-swoop.

    The design philosophy of CTRLF is to:

    - replicate the user experience that users expect from text search
      based on widespread implementations of ctrl+F functionality

    - re-use the flow and keybindings of Isearch

    - emphasize reliability and consistency

    As such, if you are familiar with Isearch then you will probably
    be at home in CTRLF.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ctrlf
        :hook (emacs-startup . ctrlf-mode)
        ;:general ("C-s" 'ctrlf-forward-symbol-at-point)
        :custom
        (ctrlf-auto-recenter t))
    #+END_SRC

*** Highlight matches in query-replace mode
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq query-replace-highlight t)
    #+END_SRC

*** Make escaping in elisp a little easier

    =easy-escape-minor-mode= uses syntax highlighting and composition to make
    ELisp regular expressions more readable. More precisely, it hides double
    backslashes preceding regexp specials (()|), composes other double
    backslashes into single ones, and applies a special face to each. The
    underlying buffer text is not modified.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package easy-escape
      :hook ((lisp-mode emacs-lisp-mode) . easy-escape-minor-mode))
    #+END_SRC

*** Add visual feedback for regex searching

    =visual-regexp= for Emacs is like =replace-regexp=, but with live
    visual feedback directly in the buffer.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package visual-regexp)
    #+END_SRC

*** Add ability to replace with inflections

    This adds an "inflection" aware version of query-replace. For
    example, replacing =foo_bar= with =baz_quux= will also replace
    =foo_bars= with =baz_quuxes=, =FooBar= with =BazQuux=, =FOO_BAR= with
    =BAZ_QUUX=, and so on.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package replace-with-inflections)
    #+END_SRC

*** Add =deadgrep= for searching

    Ripgrep is faster than grep, and =deadgrep= provides a great
    UI. It also allows inline editing through =deadgrep-edit-mode=,
    which is great for refactoring in combination with =visual-regexp=.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package deadgrep
        :custom
          (custom deadgrep-max-buffers 5)
          (deadgrep-display-buffer-function 'switch-to-buffer) ; use current buffer
        :general
          (:keymaps 'global
           :prefix "C-c s"
           "" '(:ignore t :which-key "Search") ;; rename +prefix
           "r" '(replace-string :which-key "String Replace")
           "R" '(vr/query-replace :which-key "Regex Replace")
           "i" '(query-replace-with-inflections :which-key "Inflection Replace")
           "d" 'deadgrep :which-key "Deadgrep (search)")
           (:keymaps 'deadgrep-mode-map
           "e" 'deadgrep-edit-mode
           "t" (lambda () (interactive) (deadgrep--search-term nil))
           "r" (lambda () (interactive) (setq deadgrep--search-type 'regexp) (deadgrep-restart))
           "s" (lambda () (interactive) (setq deadgrep--search-type 'string) (deadgrep-restart))
           "d" (lambda () (interactive) (deadgrep--directory nil))
           "?" 'which-key-show-major-mode)
           (:keymaps 'deadgrep-edit-mode-map
           "<escape>" 'deadgrep-mode)
        :config
          (defun config-editing--on-enter-deadgrep-edit-mode (&rest _)
            (message "Entering edit mode. Changes will be made to underlying files as you edit."))
          (defun config-editing--on-exit-deadgrep-edit-mode (&rest _)
            (when (derived-mode-p 'deadgrep-edit-mode)
              (message "Exiting edit mode.")))
          (advice-add #'deadgrep-edit-mode :after #'config-editing--on-enter-deadgrep-edit-mode)
          (advice-add #'deadgrep-mode :before #'config-editing--on-exit-deadgrep-edit-mode)
          (defun deadgrep--format-command-patch (rg-command)
            "Add --hidden to rg-command."
            (replace-regexp-in-string "^rg " "rg --hidden " rg-command)))
    #+END_SRC

*** Synonym injection

    Note, wordnet needs to be available on the system.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package synosaurus
        :commands (synosaurus-mode
                   synosaurus-lookup
        p           synosaurus-choose-and-replace)
        :general
          (:prefix "C-c S"
           "" '(:ignore t :which-key "Spelling") ;; rename +prefix
           "r" #'synosaurus-choose-and-replace)
        :custom
         (synosaurus-backend 'synosaurus-backend-wordnet
          synosaurus-choose-method 'default))
    #+END_SRC

** Dired
*** Disable use of unsupported =--dired= flag when using =ls= on macOS
    #+begin_src emacs-lisp :tangle yes
    (when (string= system-type "darwin")
      (setq dired-use-ls-dired nil))
    #+end_src
*** Set listing switches
    #+begin_src emacs-lisp :tangle yes
    (setq dired-listing-switches "-alh")
    #+end_src
*** DWIM
    #+begin_src emacs-lisp :tangle yes
    (setq dired-dwim-target t)
    #+end_src
*** Collapse paths like Github does
    #+begin_src emacs-lisp :tangle yes
    (use-package dired-collapse
      :hook (dired-mode . dired-collapse-mode)
      :commands (dired-collapse-mode))
    #+end_src
*** Provide better listing similar to =k= and =ll=
    #+begin_src emacs-lisp :tangle yes
    (use-package dired-k
      :custom
        (dired-k-human-readable 1)
        (dired-k-padding 1)
      :config
        (add-hook 'dired-initial-position-hook 'dired-k)
      )
    #+end_src

** Term

    #+begin_src emacs-lisp :tangle yes
      (use-package vterm
        :custom
        (shell-file-name "/bin/zsh"))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (use-package eat
        :straight (eat :type git :host github :repo "kephale/emacs-eat")
        :custom
          (eat-kill-buffer-on-exit t)
          (shell-file-name "/bin/zsh")
          )
    #+end_src

** Tramp

    TRAMP mode is excellent for editing files on a remote machine or
    Docker container, but it needs some TLC.

    #+begin_src emacs-lisp :tangle yes
      (use-package tramp
        :straight nil ;; it's a built-in
        :custom
        (tramp-default-method "ssh")
        (tramp-verbose 1)
        (tramp-default-remote-shell "/bin/bash")
        (tramp-connection-local-default-shell-variables
         '((shell-file-name . "/bin/bash")
           (shell-command-switch . "-c")))
        :config
        (connection-local-set-profile-variables 'tramp-connection-local-default-shell-profile
                                                '((shell-file-name . "/bin/bash")
                                                  (shell-command-switch . "-c"))))
    #+end_src
** Version Control
*** Highlight diff in fringe
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package diff-hl
      :hook (emacs-startup . global-diff-hl-mode)
      :general
        (:keymaps 'goto-map
         "M-n" 'diff-hl-next-hunk
         "M-p" 'diff-hl-previous-hunk))
    #+END_SRC

*** Use Magit for version control
    #+begin_src emacs-lisp :tangle yes
      (use-package magit
        :general ("C-x g" 'magit-status)
        :hook (magit-add-section . magit-insert-tracked-files)
        :custom
          (magit-branch-arguments nil)
          (magit-branch-read-upstream-first 'fallback)
          (magit-diff-paint-whitespace t)
          (magit-diff-highlight-indentation (quote (("" . tabs))))
          (magit-fetch-arguments (quote ("--prune")))
          (magit-pull-arguments (quote ("--rebase" "--autostash")))
          (magit-push-arguments (quote ("--set-upstream")))
          (magit-log-arguments (quote ("--graph" "--color" "--decorate" "-n256")))

          ;; Popup the process buffer if a command takes longer than this many seconds.
          (magit-process-popup-time 5)

          (magit-repolist-columns
           '(("Name"    25 magit-repolist-column-ident ())
             ("Version" 25 magit-repolist-column-version ())
             ("D"        1 magit-repolist-column-dirty ())
             ("⇣"      3 magit-repolist-column-unpulled-from-upstream
              ((:right-align t)
               (:help-echo "Upstream changes not in branch")))
             ("⇡"        3 magit-repolist-column-unpushed-to-upstream
              ((:right-align t)
               (:help-echo "Local changes not in upstream")))
             ("Path"    99 magit-repolist-column-path ())))
          (magit-repository-directories
           `(
             ("~/Clients/flexibility" . 2)
             ("~/Clients/tgu" . 2)
             ("~/Projects" . 2)
             ))
        :config
          (transient-append-suffix 'magit-pull "C"
            '("A" "Autostash" "--autostash"))
        )
    #+end_src

**** Ensure branch names do not contain whitespace
     When typing a branch name, entering whitespace will cause an annoying
     warning. Instead, simply insert a dash and continue.

     #+BEGIN_SRC emacs-lisp :tangle yes
     (advice-add 'magit-whitespace-disallowed :around
       (lambda (orig-fun &rest args) (interactive) (insert "-")))
     #+END_SRC

**** Ensure the =magit-process= window shows for git hooks

     Trying =magit-process-popup-time= instead.

     #+BEGIN_SRC emacs-lisp :tangle no
       (defun auto-display-magit-process-buffer (&rest args)
         "Automatically display the process buffer when it is updated."
         (let ((magit-display-buffer-noselect t))
           (magit-process-buffer)))

       (advice-add 'magit-process-insert-section :before
                   #'auto-display-magit-process-buffer)
     #+END_SRC

**** Smerge mode [disabled]
    #+begin_src emacs-lisp :tangle no
    (use-package smerge-mode
      :config
      (hercules-def :toggle-funs #'smerge-mode
                    :keymap 'smerge-basic-map
                    :show-funs '(smerge-next smerge-prev)
                    :transient t))
    #+end_src

**** Keep the Magit status buffer fresh

    #+begin_src emacs-lisp :tangle no
      (use-package magit-filenotify
        :hook (magit-status-mode-hook . magit-filenotify-mode))
    #+end_src

*** Smerge

    #+begin_src emacs-lisp :tangle no
      (use-package smerge
        :straight nil ;; it's a built-in
        :config
        (defun smerge-repeatedly ()
          "Perform smerge actions again and again"
          (interactive)
          (smerge-mode 1)
          (smerge-transient))
        (with-eval-after-load 'transient
          (transient-define-prefix smerge-transient ()
            [["Move"
              ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
              ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
             ["Keep"
              ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
              ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
              ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
              ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
              ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
             ["Diff"
              ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
              ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
              (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
              ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
              ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
             ["Other"
              ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
              ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
              ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
              ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]])))
    #+end_src

*** Browse-at-remote
    =browse-at-remote= opens the current buffer at the remote from Emacs.

    It works with (amongst others):
    - github
    - gitlab
    - bitbucket
    - sourcehut
    - stash

    It supports various kind of emacs buffer, like:
    - file buffer
    - dired buffer
    - magit-mode buffers representing code
    - vc-annotate mode (get there with =C-x v g= by default)

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package browse-at-remote
        :general
          (:keymaps 'goto-map
           "r" 'browse-at-remote)
          )
    #+END_SRC

*** Follow "Conventional Commits" guidelines
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package conventional-commit
        :straight (conventional-commit :type git :host github :repo "akirak/conventional-commit.el")
        :hook
        (git-commit-mode . conventional-commit-setup))
    #+END_SRC
*** Projects

    #+begin_src emacs-lisp :tangle yes
      (use-package projectile
        :hook (emacs-startup . projectile-mode)
        :general
        (:keymaps 'global
         "C-x p" '(:keymap projectile-command-map :package projectile :which-key "Projectile"))
        (:keymaps 'projectile-command-map
         "A" 'projectile-add-known-project
         "K" 'projectile-remove-known-project)
        :custom
        (projectile-enable-caching t)
        ; Show the magit status for a project when first opening it
        (projectile-switch-project-action 'my/magit-status)
        )
    #+end_src

**** Custom switch command

     The following will open the =magit-status= "full screen" when
     switching to a project for the first time, but then will follow
     magit's default rules for opening the status buffer afterwards.

     This is useful to get an overview of the state of a project when
     first switching to it, but doesn't affect workflow later on when
     using multiple magit buffers or comparing magit buffers against
     work buffers.

     #+begin_src emacs-lisp :tangle yes
      (defun my/magit-status ()
        (interactive)
        (magit-status))

      (defadvice my/magit-status (around magit-fullscreen activate)
        (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
        ad-do-it
        (setq magit-display-buffer-function #'magit-display-buffer-traditional))
     #+end_src

**** Add perspectives (workspaces)

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package perspective
         :custom
         (persp-mode-prefix-key (kbd "C-x C-p"))
         )
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package persp-projectile
         :hook (emacs-startup . persp-mode)
         :general
         (:keymaps 'perspective-map
          "x" 'projectile-persp-switch-project)
          ;; override projectile-switch-project since
          ;; we always want to be in a perspective
         (:keymaps 'projectile-command-map
          "p" 'projectile-persp-switch-project)
         )
     #+END_SRC
**** Add Projectile details to ibuffer

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package ibuffer-projectile
         :hook (ibuffer-hook . (lambda ()
                                 (ibuffer-projectile-set-filter-groups)
                                 (unless (eq ibuffer-sorting-mode 'alphabetic)
                                   (ibuffer-do-sort-by-alphabetic))))
         :custom
         (ibuffer-formats
          '((mark modified read-only " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  project-relative-file)))
         )
     #+END_SRC

** Org
*** Hide emphasis markers
    With this option enabled, markers like =\==, =/=, =*= are hidden
    which makes for a neater view.

    #+begin_src emacs-lisp :tangle yes
    (setq org-hide-emphasis-markers t)
    #+end_src

*** Enable shift-selection
    Standard Emacs =S-<cursor>= commands conflict with Org’s use of
    =S-<cursor>= to change timestamps, TODO keywords, priorities, and
    item bullet types, etc. Since =S-<cursor>= commands outside of
    specific contexts do not do anything, Org offers the variable
    =org-support-shift-select= for customization. Org mode accommodates
    shift selection by:

      1. making it available outside of the special contexts where special
         commands apply, and
      2. extending an existing active region even if point moves across a
         special context.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (setq org-support-shift-select t)
    #+END_SRC

*** Add font styles to =DONE= lines
    It's useful to have titles like =TODO= and =DONE= hilight differently.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-fontify-done-headline t)
    #+END_SRC

*** =SRC= blocks
**** Style src blocks natively
     #+BEGIN_SRC emacs-lisp :tangle yes
       (setq org-src-fontify-natively t)
     #+END_SRC
**** Allow indenting natively within source blocks.
     #+BEGIN_SRC emacs-lisp :tangle yes
       (setq org-src-tab-acts-natively t
             org-cycle-emulate-tab t)
     #+END_SRC
*** Org Extensions
**** Replace Org's bullets with something less noisy
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package org-bullets
         :after org
         :hook (org-mode . org-bullets-mode)
         :custom
           (org-bullets-bullet-list '("☰" "☷" "▶" "●" "✱" "✲" "✸" "⦿" "⌾" "◦"))
         )
     #+END_SRC

** Programming
*** General enhancements
**** =xref=

     #+BEGIN_SRC emacs-lisp :tangle yes
       ;; Let me control what backends to fall back on
       (setq-default xref-backend-functions '(t))
     #+END_SRC

**** DWIM with comments
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package comment-dwim-2
       :general ("M-;" 'comment-dwim-2))
     #+END_SRC

**** Add/remove line breaks between function arguments and similar constructs
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package fill-function-arguments
       :general (:keymaps 'prog-mode-map
                 "M-q" 'fill-function-arguments-dwim)
       :hook (sgml-mode-hook . (lambda ()
                                 (setq-local fill-function-arguments-first-argument-same-line t)
                                 (setq-local fill-function-arguments-argument-sep " "))))
     #+END_SRC

**** Jump to definition using =dumb-jump=

    Note: using init to add the hooks here because the :hook keyword
    doesn't correctly add dumb-jump.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package dumb-jump
        :hook
        (xref-backend-functions . dumb-jump-xref-activate)
        ;:init
        ;(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
        ;(add-to-list 'xref-backend-functions #'dumb-jump-xref-activate t)
        :general
        (:keymaps 'goto-map
         "j" '(:ignore t :which-key "jump to") ;; rename +prefix
         "j j" 'dumb-jump-go
         "j b" 'dumb-jump-back
         "j o" 'dumb-jump-go-other-window)
        :custom
        (dumb-jump-prefer-searcher 'rg)
        (xref-show-definitions-function #'xref-show-definitions-completing-read)
        )
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package dumb-jump
        :init
          (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
        ;:config
        ;  (remove-hook 'xref-backend-functions #'etags--xref-backend)
        :general
        (:keymaps 'goto-map
         "j" '(:ignore t :which-key "jump to") ;; rename +prefix
         "j j" 'dumb-jump-go
         "j b" 'dumb-jump-back
         "j o" 'dumb-jump-go-other-window)
        :custom
        (dumb-jump-prefer-searcher 'rg)
        (xref-show-definitions-function #'xref-show-definitions-completing-read)
        )
    #+END_SRC

**** Toggle between the test and implementation files [disabled]

    Causes a recursive load error.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package toggle
        :straight (:package "toggle"
                   :host github
                   :repo "zenspider/elisp"
                   :branch "master"
                   :files ("toggle.el"))
        :general
        ("C-c t" '(toggle-buffer :which-key "Toggle code/test"))
        ;:config
        ;(add-to-list 'toggle-mapping-styles '(elixir . (("lib/\\\1.ex" . "test/\\\1_test.exs"))))
        )
    #+END_SRC

**** Auto-format code using =apheleia=

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package apheleia
        :hook
        (emacs-startup . apheleia-global-mode)
        :config
        (push '(mix-format "mix" "format" "-") apheleia-formatters)
        (push '(elixir-mode . mix-format) apheleia-mode-alist)
        (push '(graphql-mode . prettier) apheleia-mode-alist)
        )
    #+END_SRC

***** Fix formatting for Elixir

    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/fix-apheleia-project-dir (orig-fn &rest args)
        (let ((project (project-current)))
          (if (not (null project))
              (let ((default-directory (project-root project))) (apply orig-fn args))
            (apply orig-fn args))))

      (advice-add 'apheleia-format-buffer :around #'my/fix-apheleia-project-dir)
    #+END_SRC

*** Language Server Protocol

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package lsp-mode
        :init
        ;; Performace tuning
        ;; @see https://emacs-lsp.github.io/lsp-mode/page/performance/
        ;(setq read-process-output-max (* 1024 1024)) ;; 1MB
        (setq read-process-output-max 4194304) ;; 4MB
        ;(setenv "LSP_USE_PLISTS" "true")
        :commands (lsp lsp-deferred)
        :hook ((lsp-mode . lsp-enable-which-key-integration)
               ;(elixir-mode . lsp-deferred)
               (lsp-mode . (lambda () (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate t)))
               )
        :config
          (with-eval-after-load 'lsp-mode
            (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.direnv\\'")
            (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.git\\'")
            (remove-hook 'xref-backend-functions 't)
            (add-hook 'xref-backend-functions #'dumb-jump-xref-activate 0)

            ;; DANGER: dumb-jump-xref-activate as a backend after
            ;; lsp--xref-backend won't complain if git-grep is left as
            ;; the default searcher. However, if setting ripgrep as
            ;; the preferred for everything except for git with (setq
            ;; dumb-jump-prefer-searcher 'rg) it repeatedly raises:
            ;; Blocking call to accept-process-output with quit inhibited!!
            (add-hook 'xref-backend-functions #'lsp--xref-backend 0)
            )
        :custom
          ;(lsp-use-plists t) ;; only use with LSP_USE_PLISTS
          (xref-search-program 'ripgrep)
          (lsp-keymap-prefix "C-c l")
          (lsp-auto-configure t)
          (lsp-auto-guess-root t)
          (lsp-eldoc-enable-hover nil)
          (lsp-enable-completion-at-point t)
          (lsp-enable-file-watchers t)
          (lsp-file-watch-threshold 10000)
          (lsp-keep-workspace-alive nil)
          (lsp-log-io nil) ;; enable for debugging
          (lsp-prefer-flymake nil)
          (lsp-enable-xref nil) ;; needed to allow customization of backends
          ;(lsp-enable-xref t)
          (lsp-prefer-capf t)
        )
    #+END_SRC


    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package lsp-mode
        :init
        ;; Performace tuning
        ;; @see https://emacs-lsp.github.io/lsp-mode/page/performance/
        ;(setq read-process-output-max (* 1024 1024)) ;; 1MB
        (setq read-process-output-max 4194304) ;; 4MB
        ;(setenv "LSP_USE_PLISTS" "true")
        :commands (lsp lsp-deferred)
        :hook
          ((lsp-mode . lsp-enable-which-key-integration)
           (lsp-mode . lsp-headerline-breadcrumb-mode))
        :config
          (with-eval-after-load 'lsp-mode
            (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.direnv\\'")
            (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.git\\'")
            )
        :custom
          ;(lsp-use-plists t)
          (xref-search-program 'ripgrep)
          (lsp-keymap-prefix "C-c l")
          (lsp-auto-configure t)
          (lsp-auto-guess-root t)
          ;(lsp-eldoc-enable-hover nil)
          ;(lsp-enable-completion-at-point t)
          (lsp-enable-file-watchers t)
          ;(lsp-enable-on-type-formatting nil)
          (lsp-file-watch-threshold 10000)
          ;(lsp-keep-workspace-alive nil)
          (lsp-log-io t)
          ;(lsp-prefer-flymake nil)
          (lsp-prefer-capf t)
          (lsp-enable-xref t)
          ;(lsp-headerline-breadcrumb-enable t)
          ;(lsp-headerline-breadcrumb-enable-diagnostics t)
          ;(lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
          ;(lsp-completion-provider :none)
        )
    #+END_SRC

**** Add useful UI features

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package lsp-ui
         :after lsp-mode
         :commands lsp-ui-mode
         :general
          (:keymaps 'lsp-ui-mode-map
            [remap xref-find-definitions] 'lsp-ui-peek-find-definitions
            [remap xref-find-references] 'lsp-ui-peek-find-references))
     #+END_SRC

*** Debug Adapter Protocol [DISABLED]

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package dap-mode)
    #+END_SRC

*** Tree-Sitter
    Tree-sitter is an incremental parsing library which aims to be the
    foundation for a new breed of Emacs packages that understand code
    structurally. It can be the basis for things like : Faster,
    fine-grained code highlighting; More flexible code folding;
    Structural editing (like Paredit, or even better) for non-Lisp
    code.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package tree-sitter)
      (use-package tree-sitter-langs
        :requires tree-sitter
        :hook
        (emacs-startup . global-tree-sitter-mode)
        ; To enable it whenever possible
        (tree-sitter-after-on-hook . tree-sitter-hl-mode)
        )
    #+END_SRC

*** Flycheck

    Flycheck is a modern on-the-fly syntax checking extension for
    emacs. It uses various syntax checking and linting tools to
    automatically check the contents of buffers while you type, and
    reports warnings and errors directly in the buffer, or in an
    optional error list.

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flycheck
      :hook (emacs-startup . global-flycheck-mode)
      :general ("C-c !" '(:ignore t :which-key "FlyCheck")) ;; rename +prefix
      )
    #+END_SRC

**** Integrate with =Consult=

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package consult-flycheck)
     #+END_SRC

**** Change the modeline color to indicate errors using =flycheck-color-mode-line=

     An Emacs minor-mode for Flycheck that changes the color of the mode line
     according to the Flycheck state of the current buffer.

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package flycheck-color-mode-line
         :hook (flycheck-mode . flycheck-color-mode-line-mode))
     #+END_SRC

**** Show flycheck messages inline

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package flycheck-inline
         :hook (flycheck-mode . flycheck-inline-mode))
     #+END_SRC

*** More intelligent fill with =prog-fill=

    =prog-fill= brings the =M-q= keybinding to programming modes,
    reflowing code to be more readable with a single keypress.

    #+begin_src emacs-lisp :tangle yes
      (use-package prog-fill
        :hook (prog-mode-hook . (lambda () (local-set-key (kbd "M-q") #'prog-fill))))
    #+end_src

*** Languages
**** Elixir
***** Add elixir mode
      #+BEGIN_SRC emacs-lisp :tangle yes
        (use-package elixir-mode
          :mode "\\.exs?\\'"
          :hook ((elixir-mode . prettify-symbols-mode)
                 (elixir-mode . lsp-deferred)
                 (elixir-mode . (lambda () (projectile-register-project-type 'elixir '("mix.exs")
                                  :compile "mix deps.get"
                                  :test "mix test --no-color"
                                  :run "mix app.start"
                                  :src-dir "lib"
                                  :test-dir "test"
                                  :test-suffix "_test"
                                  :related-files-fn 'phx/related-files)

                                  )))
          :init
          (add-to-list 'exec-path "~/Projects/elixir/elixir-ls/release")
          (defun phx/related-files (path)
            (let* ((filename (file-name-nondirectory path))
                   (files (projectile-project-files (projectile-project-root))))
              (when (string-match (rx (group (+ alpha)) "_") filename)
                (let ((prefix (match-string 1 filename)))
                  (list :templates (cl-remove-if-not
                                    (lambda (file)
                                      (string-match (concat "templates/" prefix) file))
                                    files))))))
          :config
          (with-eval-after-load 'lsp
            (dolist (dir '("build$" "deps$"))
              (push (concat "[/\\\\]" dir) lsp-file-watch-ignored)))
            (setq-local paragraph-start
              (rx (or (group (* whitespace) num "." (* any) eol)
                      (group (* whitespace) eol))))
            (setq-local paragraph-separate
              (rx (or (group (* any) "\"\"\"" (* whitespace) eol)
                      (group (* whitespace) eol))))
            (with-eval-after-load 'lsp-mode
              (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]build\\'")
              (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]deps\\'")
              )

          :custom
          (lsp-elixir-suggest-specs t)
          (lsp-elixir-enable-test-lenses t)

          :general
            (:keymaps 'elixir-mode-map
             "M-q" 'elixir-mode-fill-doc-string)
          )
      #+END_SRC

      #+BEGIN_SRC emacs-lisp :tangle no
        (use-package elixir-mode
          :mode "\\.exs?\\'"
          :hook ((elixir-mode . prettify-symbols-mode)
                 (elixir-mode . lsp-deferred)
                 (elixir-mode . (lambda () (projectile-register-project-type 'elixir '("mix.exs")
                                  :compile "mix deps.get"
                                  :test "mix test --no-color"
                                  :run "mix app.start"
                                  :src-dir "lib"
                                  :test-dir "test"
                                  :test-suffix "_test"
                                  :related-files-fn 'phx/related-files)

                                  )))
          ;((elixir-mode . lsp-deferred)
           ;(before-save .(lambda () (when (eq major-mode 'elixir-mode)
           ;                           (ignore-errors 'lsp-format-buffer))))
           ;(elixir-mode . elixir-mode-prettify-symbols-hook)
           ;)
          :init
          (add-hook 'xref-backend-functions #'lsp--xref-backend nil t)
          (add-to-list 'exec-path "~/Projects/elixir/elixir-ls/release")
          (defun phx/related-files (path)
            (let* ((filename (file-name-nondirectory path))
                   (files (projectile-project-files (projectile-project-root))))
              (when (string-match (rx (group (+ alpha)) "_") filename)
                (let ((prefix (match-string 1 filename)))
                  (list :templates (cl-remove-if-not
                                    (lambda (file)
                                      (string-match (concat "templates/" prefix) file))
                                    files))))))
          :config
          (with-eval-after-load 'lsp
            (dolist (dir '("build$" "deps$"))
              (push (concat "[/\\\\]" dir) lsp-file-watch-ignored)))
            (setq-local paragraph-start
              (rx (or (group (* whitespace) num "." (* any) eol)
                      (group (* whitespace) eol))))
            (setq-local paragraph-separate
              (rx (or (group (* any) "\"\"\"" (* whitespace) eol)
                      (group (* whitespace) eol))))
            (with-eval-after-load 'lsp-mode
              (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]build\\'")
              (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]deps\\'")
              )
          :custom
          (lsp-elixir-suggest-specs t)
          ;(lsp-lens-enable t)
          )
      #+END_SRC

          :config
          (defun er/add-elixir-mode-expansions ()
            (make-variable-buffer-local 'er/try-expand-list)
            (setq er--python-block-start-regex
                  (rx symbol-start
                      (or "def" "do" "if" "else"
                          "try" "except" "catch" "rescue" "finally"
                          "for" "while" "with"
                          "test" "describe")
                      symbol-end))
            (setq er/try-expand-list '(er/mark-subword
                                       er/mark-word
                                       er/mark-inside-python-string
                                       er/mark-outside-python-string
                                       er/mark-python-statement
                                       er/mark-python-block)
                                      ))
          (with-eval-after-load 'expand-region
            (er/enable-mode-expansions 'elixir-mode 'er/add-elixir-mode-expansions))

***** Add mix as a minor mode
      #+BEGIN_SRC emacs-lisp :tangle yes
        (use-package mix
          :config
          (add-hook 'elixir-mode-hook 'mix-minor-mode))
      #+END_SRC
***** Add =ruby-end-mode= to auto-insert =end= for blocks

      #+BEGIN_SRC emacs-lisp :tangle yes
        (use-package ruby-end
          :hook (elixir-mode . ruby-end-mode))
      #+END_SRC

***** Add support for =.(l|h)eex= files

      Switch on =web-mode= so that HTML templates can be edited properly.

      #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'auto-mode-alist '("\\.(l|h)?eex\\'" . web-mode))
      #+END_SRC

***** Add function to insert/remove breakpoint

      #+BEGIN_SRC emacs-lisp :tangle yes
        (defun my/elixir-toggle-breakpoint ()
          "Add a breakpoint line or clear it if line is already a breakpoint."
          (interactive)
          (let ((trace "require IEx; IEx.pry")
                (line (thing-at-point 'line)))
            (if (and line (string-match trace line))
                (kill-whole-line)
              (progn
                (back-to-indentation)
                (insert trace)
                (newline-and-indent)))))
      #+END_SRC

***** Add =flycheck-credo=

      #+BEGIN_SRC emacs-lisp :tangle yes
        (use-package flycheck-credo
          :config
          (flycheck-credo-setup)
          :custom
          (flycheck-elixir-credo-strict t))
      #+END_SRC

***** Add =exunit= for test running
      #+BEGIN_SRC emacs-lisp :tangle yes
        (use-package exunit
          :hook (elixir-mode . exunit-mode))
      #+END_SRC

***** Define custom elixir keymap

      Elixir keys start with =C-c C-e=.

      #+BEGIN_SRC emacs-lisp :tangle yes
        (general-define-key
          :keymaps 'elixir-mode-map
          :prefix "C-c C-e"
          "" '(nil :which-key "Elixir")
          "t" '(exunit-transient :which-key "test")
          "i" '(exunit-toggle-file-and-test :which-key "toggle file/test")
          "I" '(exunit-toggle-file-and-test-other-window :which-key "↗ toggle file/test")
          "X" '(xref-find-definitions :which-key "xref defs")
          "x" '(xref-find-definitions-other-window :which-key "↗ xref defs")
          "j" '(dumb-jump-go :which-key "dumb-jump to def")
          "J" '(dumb-jump-go-other-window :which-key "↗ dumb-jump to def")
          "f" '(elixir-format :which-key "format")
          "p" '(my/elixir-toggle-breakpoint :which-key "toggle pry")
          "d" '(elixir-mode-fill-doc-string :which-key "fill docstring")
          "!" '(mix-minor-mode-command-map :which-key "run mix mask")
          )
      #+END_SRC

***** Add some useful shortcuts

      #+BEGIN_SRC emacs-lisp :tangle yes
        (defun my/elixir-insert-pipe ()
          (interactive)
          (princ "\n" (current-buffer))
          (princ "|> " (current-buffer))
          (indent-according-to-mode))

        (general-define-key
         :keymaps 'elixir-mode-map
         "M-<return>" 'my/elixir-insert-pipe)

        (defun my/toggle-ex-leex ()
          (interactive)
          (cond
           ((string-suffix-p ".ex" (buffer-file-name))
            (find-file (string-replace ".ex" ".html.leex" (buffer-file-name))))
           ((string-suffix-p ".html.leex" (buffer-file-name))
            (let ((sym (thing-at-point 'symbol)))
              (find-file (string-replace ".html.leex" ".ex" (buffer-file-name)))
              (when sym
                (let (pos)
                  (save-mark-and-excursion
                    (goto-char (point-min))
                    (setq pos (re-search-forward (format "\"%s\"" (regexp-quote sym)) nil t)))
                  (when pos (goto-char pos) (recenter))))))
           (t
            (error "File extension is neither .ex nor .html.leex"))))

        (defun my/toggle-ex-heex ()
          (interactive)
          (cond
           ((string-suffix-p ".ex" (buffer-file-name))
            (find-file (string-replace ".ex" ".html.heex" (buffer-file-name))))
           ((string-suffix-p ".html.heex" (buffer-file-name))
            (let ((sym (thing-at-point 'symbol)))
              (find-file (string-replace ".html.heex" ".ex" (buffer-file-name)))
              (when sym
                (let (pos)
                  (save-mark-and-excursion
                    (goto-char (point-min))
                    (setq pos (re-search-forward (format "\"%s\"" (regexp-quote sym)) nil t)))
                  (when pos (goto-char pos) (recenter))))))
           (t
            (error "File extension is neither .ex nor .html.heex"))))

        (defun my/elixir-map-atom-to-map-string (&optional begin end)
          "Transform Elixir map atom to map string. Use BEGIN and END as region."
          (interactive "r")
          (save-excursion
            (let ((min (if (region-active-p) begin (point-min))))
              (goto-char min)
              (while (re-search-forward "\\([a-zA-z0-9]+\\): " end t)
                (replace-match "\"\\1\" => "))
              (goto-char min))))

        (defun my/elixir-map-string-to-map-atom (&optional begin end)
          "Transform Elixir map string to map atom. Use BEGIN and END as region."
          (interactive "r")
          (save-excursion
            (let ((min (if (region-active-p) begin (point-min))))
              (goto-char min)
              (while (re-search-forward "\"\\([a-zA-z0-9]+\\)\" => " end t)
                (replace-match "\\1: "))
              (goto-char min))))

        (general-define-key
          :keymaps 'elixir-mode-map
          :prefix "C-c C-e"
          "l" '(my/toggle-ex-leex :which-key "toggle ex/leex")
          "h" '(my/toggle-ex-heex :which-key "toggle ex/heex")
          "m" '(my/elixir-map-string-to-map-atom :which-key "map: => to kw")
          "M" '(my/elixir-map-atom-to-map-string :which-key "map: kw to =>")
          )
      #+END_SRC


***** Fix-up how Projectile handles test/implementation toggling

      For Elixir we should jump to =*_test.exs= (with an =s= suffix)
      instead of =*_test.ex=

      #+BEGIN_SRC emacs-lisp :tangle yes
        (defun my/fix-exs-test-file-name (name)
          (cond
           ((string-suffix-p "_test.ex" name) (concat name "s"))
           (t name)))

        (advice-add #'projectile--test-name-for-impl-name
                    :filter-return
                    #'my/fix-exs-test-file-name)
      #+END_SRC
**** HTML et al

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package web-mode
         :mode
         "\\.html?\\'"
         "\\.mustache\\'"
         "\\.ecr\\'"
         "\\.erb\\'"
         "\\.jsx\\'"
         "\\.jinja\\'"
         :custom
         (web-mode-markup-indent-offset 2)
         (web-mode-css-indent-offset 2)
         (web-mode-code-indent-offset 2)
         (web-mode-enable-auto-pairing t)
         (web-mode-enable-current-element-highlight t)
         (web-mode-engines-alist
          '(("\\.jinja\\'"  . "django")))
         :config
         ;; use eslint with web-mode for jsx files
         (with-eval-after-load 'flycheck
           (flycheck-add-mode 'javascript-eslint 'web-mode)))
     #+END_SRC

**** JavaScript

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package js2-mode
         :mode
         "\\.js\\'"
         "\\.json\\'"
         :custom
         (js-indent-level 4)
         (js2-basic-offset 4)
         (tab-width 4)
         (js-switch-indent-offset 4))
     #+END_SRC

***** TypeScript

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package typescript-mode
         :hook
         ((typescript-mode . tide-hl-identifier-mode)
          (typescript-mode . lsp))
         :mode (("\\.tsx\\'" . typescript-mode)
                ("\\.ts\\'" . typescript-mode))
         :custom
         (typescript-indent-level 2)
         )
     #+END_SRC

***** Tide

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package tide
         :hook ((before-save . tide-format-before-save)
                (web-mode . (lambda() (tide-setup) (eldoc-mode)))
                (typescript-mode . (lambda() (tide-setup) (eldoc-mode)))
                (rjsx-mode . (lambda() (tide-setup) (eldoc-mode)))
                )
         :custom
         (tide-format-options '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t)))
     #+END_SRC

***** Vue

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package vue-mode
         :hook (vue-mode . lsp)
         :mode
         "\\.vue\\'"
         )
     #+END_SRC

**** Crystal
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package crystal-mode
        :hook
        ((crystal-mode . ruby-block-mode)
         (crystal-mode . ruby-end-mode))
        :mode
        "\\.cr\\'")
     #+END_SRC
***** Add flycheck
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package flycheck-crystal
         :after (flycheck crystal-mode))
     #+END_SRC
**** Nim
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package nim-mode
        :mode
        "\\.nim\\'")
     #+END_SRC
**** Rust
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package rust-mode
        :custom
        (rust-format-on-save t)
        :hook (lsp)
        :mode
        "\\.rs\\'")
      (use-package flycheck-rust
        :after flycheck
        :hook (flycheck-rust-setup))
      (use-package rust-auto-use
        :after rust-mode)
     #+END_SRC
      (use-package cargo-transient
        :custom
        (cargo-transient-buffer-name-function '#project-prefixed-buffer-name))
***** Rust Object Notation
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package ron-mode
         :mode
         "\\.ron\\'")
      #+END_SRC
**** GraphQL

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package graphql-mode
         :mode (("\\.graphql$" . graphql-mode)
                ("\\.graphqls$" . graphql-mode)
                ("\\.gql$" . graphql-mode))
         )
     #+END_SRC

**** Sass/Scss

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package sass-mode
         :mode
         "\\.s(c|a)ss\\'")
     #+END_SRC
**** Yaml

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package yaml-mode
        :mode
        "\\.ya?ml\\'")
     #+END_SRC

**** TOML

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package toml-mode
        :mode
        "\\.toml\\'")
     #+END_SRC

**** Markdown

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package markdown-mode
         :mode
         "\\.md\\'")
     #+END_SRC

**** Docker

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package dockerfile-mode
         :mode
         "\\Dockerfile\\'")
     #+END_SRC

**** Features/Gherkin

     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package feature-mode
         :mode
         "\\.feature\\'")
     #+END_SRC

** Finalising
*** Add profiler to diagnose start-up issues
    Doesn't seem to be working well with Emacs 29
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package esup)
    #+END_SRC
*** Normalize GC
    #+begin_src emacs-lisp :tangle yes
      ;; (setq garbage-collection-messages t) ; for debug
      (defun my/cleanup-gc ()
        "Clean up gc."
        (setq gc-cons-threshold  134217728) ; 128M
        (setq gc-cons-percentage 0.1) ; original value
        (garbage-collect))

      (run-with-idle-timer 4 nil #'my/cleanup-gc)
    #+end_src
*** "Provide" the generated file.
    #+begin_src emacs-lisp :tangle yes
      (provide 'init)
    #+end_src
